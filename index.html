<!DOCTYPE html>
<html>
<head>
    <title>Monitor Familiar</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; padding: 20px; background: #000; color: white; font-family: Arial; text-align: center; }
        button { padding: 15px 25px; margin: 10px; border: none; border-radius: 25px; font-size: 18px; background: #4CAF50; color: white; cursor: pointer; }
        button:disabled { background: #666; }
        #status { margin: 15px 0; padding: 10px; border-radius: 8px; font-weight: bold; background: #333; }
        video { width: 100%; max-width: 400px; border-radius: 10px; border: 3px solid #4CAF50; margin: 15px 0; }
    </style>
</head>
<body>
    <div>
        <h1>üì∑ Monitor Familiar</h1>
        <div id="status">‚ö´ Clique em INICIAR</div>
        
        <button id="startBtn" onclick="startTransmission()">üé• INICIAR TRANSMISS√ÉO</button>
        <button id="stopBtn" onclick="stopTransmission()" disabled>‚èπÔ∏è PARAR</button>
        
        <video id="localVideo" autoplay muted playsinline></video>
        
        <div style="margin-top: 20px; font-size: 12px; opacity: 0.8;">
            ‚úÖ Agora funciona mesmo minimizado!
        </div>
    </div>

    <script>
        let localStream = null;
        let isTransmitting = false;
        let peerConnection = null;
        let dataChannel = null;

        // Servidor WebRTC gratuito
        const signalingServer = 'wss://free-1.websocket.cc:8080';
        let websocket = null;
        const roomId = 'familia_' + Math.random().toString(36).substr(2, 8);

        async function startTransmission() {
            try {
                updateStatus('üü° Conectando...');
                
                // Conectar ao servidor WebRTC
                await connectSignalingServer();
                
                // Iniciar c√¢mera
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 320, height: 240 }, 
                    audio: false 
                });

                document.getElementById('localVideo').srcObject = localStream;
                
                // Configurar WebRTC
                await setupWebRTC();
                
                updateStatus('üü¢ TRANSMITINDO - Pode minimizar!');
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                isTransmitting = true;
                
            } catch (error) {
                updateStatus('üî¥ Erro: ' + error.message);
            }
        }

        function stopTransmission() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            if (websocket) {
                websocket.close();
            }
            if (peerConnection) {
                peerConnection.close();
            }
            
            updateStatus('‚ö´ Transmiss√£o parada');
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            isTransmitting = false;
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        async function connectSignalingServer() {
            return new Promise((resolve, reject) => {
                websocket = new WebSocket(signalingServer);
                
                websocket.onopen = () => {
                    updateStatus('üü° Conectado ao servidor...');
                    // Entrar na sala
                    websocket.send(JSON.stringify({
                        type: 'join',
                        room: roomId
                    }));
                    resolve();
                };
                
                websocket.onerror = (error) => {
                    reject(new Error('Erro servidor WebSocket'));
                };
                
                websocket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    handleSignalingMessage(data);
                };
            });
        }

        async function setupWebRTC() {
            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(configuration);

            // Adicionar stream
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Criar data channel para manter conex√£o
            dataChannel = peerConnection.createDataChannel('camData');
            
            peerConnection.oniceconnectionstatechange = () => {
                if (peerConnection.iceConnectionState === 'connected') {
                    updateStatus('üü¢ CONECTADO ao app pai!');
                }
            };

            // Criar oferta
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            // Enviar oferta via signaling
            websocket.send(JSON.stringify({
                type: 'offer',
                room: roomId,
                offer: offer
            }));
        }

        function handleSignalingMessage(data) {
            if (data.type === 'answer' && peerConnection) {
                peerConnection.setRemoteDescription(data.answer);
            }
        }

        // Manter transmiss√£o ativa mesmo em background
        let backgroundInterval;
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isTransmitting) {
                // P√°gina em background - manter conex√£o ativa
                backgroundInterval = setInterval(() => {
                    if (dataChannel && dataChannel.readyState === 'open') {
                        dataChannel.send('ping');
                    }
                }, 5000);
            } else {
                clearInterval(backgroundInterval);
            }
        });

        // Iniciar automaticamente
        setTimeout(() => {
            if (!isTransmitting) {
                startTransmission();
            }
        }, 1000);
    </script>
</body>
</html>
